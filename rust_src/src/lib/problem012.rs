/* Project Euler Problem 12 Solution
 *
 * Problem statement:
 * The sequence of triangle numbers is generated by adding
 * the natural numbers. So the 7th triangle number would be
 * 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *   2  3  4   5   6   7   8
 * Let us list the factors of the first seven triangle numbers:
 *
 *     1: 1
 *     3: 1,3
 *     6: 1,2,3,6
 *    10: 1,2,5,10
 *    15: 1,3,5,15
 *    21: 1,3,7,21
 *    28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over
 * five divisors. What is the value of the first triangle number
 * to have over five hundred divisors?
 *
 * Solution description:
 * Brute-force.
 *
 * Authors: Daniel Schuette
 * Date: 2019/03/03
 * License: MIT (see ../LICENSE.md)
 */
use crate::utils;

// Returns a vector [p, q, r, ...] of natural powers of the
// prime factors [a, b, c, ...] of `n', where
// a^p + b^q + c^r + ... = n.
pub fn prime_factor_powers(n: i64) -> Vec<i64> {
    let mut factors: Vec<i64> = vec![];
    let mut current_val: i64 = n;

    for i in 2..n as i64 {
        if utils::is_prime(i) && (n % i == 0) {
            // the current `i' is a prime factor of `n'
            // now determine how often `i' fits into `n'
            // and save the result in a variable `_power'
            let mut _power: i64 = 0;
            loop {
                if current_val % i == 0 {
                    current_val /= i;
                    _power += 1;
                } else {
                    factors.push(_power);
                    break;
                }
            }
        }
        if current_val == 1 {
            return factors;
        }
    }

    return factors; /* should never be reached #no_code */
}

// Returns the number of divisors D of a natural number `n',
// using prime factorization and the formula D = (p+1)*(q+q)...
// where p, q, ... are natural powers of the prime factors of
// `n', so that a^p + b^q + c^r + ... = n.
pub fn num_divisors(n: i64) -> i64 {
    let mut num_div: i64 = 1;
    let pow = prime_factor_powers(n);

    for p in pow {
        num_div *= p + 1;
    }
    return num_div;
}

// Returns the nth triangle number. Not actually used in this
// solution.
#[allow(dead_code)]
pub fn nth_triangle_num(n: i64) -> i64 {
    let mut num: i64 = 0;

    for i in 1..(n + 1) {
        num += i;
    }

    return num;
}

// Returns the first triangle number with more than `n' divisors.
pub fn solve(n: i64) -> i64 {
    let mut current: i64 = nth_triangle_num(n); /* current triangle number */
    let mut offset: i64 = n + 1; /* offset to next triangle number */

    loop {
        let divisors = num_divisors(current);
        if divisors > n {
            return current;
        }
        current += offset;
        offset += 1;
    }
}
